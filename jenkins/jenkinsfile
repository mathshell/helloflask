/**
 * Pipeline Jenkins pour l'application Flask
 *
 * Ce pipeline automatise les √©tapes suivantes :
 * 1. Build de l'image Docker de l'application Flask.
 * 2. Cr√©ation du cluster Kind si celui-ci n'existe pas.
 * 3. Chargement de l'image Docker dans le cluster Kind.
 * 4. D√©ploiement de l'application (Deployment et Service) dans Kubernetes.
 */

// D√©finition des variables globales
def IMAGE_NAME = 'flask-app'
def K8S_DEPLOYMENT_NAME = 'flask-app-deployment'
def K8S_SERVICE_NAME = 'flask-app-service'
def KIND_CLUSTER_NAME = 'local-dev-cluster'
def TAG = env.BUILD_NUMBER ?: 'latest'

pipeline {
    agent any

    stages {
        // √âtape 1: Construction et Tagging de l'image Docker
        stage('Build & Tag Docker Image') {
            steps {
                script {
                    echo "üî® Construction de l'image: ${IMAGE_NAME}:${TAG}"
                    // Construit l'image Docker en utilisant le Dockerfile √† la racine
                    sh "docker build -t ${IMAGE_NAME}:${TAG} ."
                    
                    // Tag l'image avec un tag 'latest' pour la rendre plus facile √† r√©f√©rencer
                    sh "docker tag ${IMAGE_NAME}:${TAG} ${IMAGE_NAME}:latest"
                }
            }
        }

        // √âtape 2: V√©rification et Cr√©ation du Cluster Kind
        stage('Setup Kind Cluster') {
            steps {
                script {
                    // V√©rifie si le cluster Kind existe
                    def clusterExists = sh(
                        script: "kind get clusters | grep -w ${KIND_CLUSTER_NAME}",
                        returnStatus: true
                    )

                    if (clusterExists != 0) {
                        echo "Cluster Kind '${KIND_CLUSTER_NAME}' non trouv√©. Cr√©ation en cours..."
                        // Cr√©e un nouveau cluster Kind
                        sh "kind create cluster --name ${KIND_CLUSTER_NAME}"
                    } else {
                        echo "Cluster Kind '${KIND_CLUSTER_NAME}' existe d√©j√†. Poursuite..."
                    }
                    
                    // S'assure que kubectl pointe vers le bon cluster
                    sh "kubectl cluster-info --context kind-${KIND_CLUSTER_NAME}"
                }
            }
        }

        // √âtape 3: Chargement de l'image dans le Cluster Kind
        stage('Load Image into Kind') {
            steps {
                script {
                    echo "üì¶ Chargement de l'image Docker dans le cluster Kind..."
                    // Kind ne peut pas acc√©der aux images Docker locales directement, elles doivent √™tre charg√©es
                    // Nous chargeons le tag 'latest' pour correspondre au manifeste K8s
                    sh "kind load docker-image ${IMAGE_NAME}:latest --name ${KIND_CLUSTER_NAME}"
                }
            }
        }

        // √âtape 4: D√©ploiement dans Kubernetes
        stage('Deploy to Kind') {
            steps {
                script {
                    echo "üöÄ D√©ploiement des manifestes Kubernetes (k8s/*.yaml)..."
                    // Applique les manifestes dans le r√©pertoire k8s
                    sh "kubectl apply -f k8s/"
                    
                    // Attend que le d√©ploiement soit pr√™t
                    sh "kubectl rollout status deployment/${K8S_DEPLOYMENT_NAME}"
                }
            }
        }

        // √âtape 5: Affichage des informations d'acc√®s
        stage('Show Access Info') {
            steps {
                script {
                    echo "‚úÖ D√©ploiement termin√©. Informations d'acc√®s au service:"
                    // R√©cup√®re le NodePort assign√© dynamiquement
                    def nodePort = sh(
                        script: "kubectl get service ${K8S_SERVICE_NAME} -o jsonpath='{.spec.ports[0].nodePort}'",
                        returnStdout: true
                    ).trim()
                    
                    // R√©cup√®re l'adresse IP du n≈ìud Kind (utile si vous utilisez un autre outil pour l'IP)
                    def nodeIP = sh(
                        script: "docker inspect -f '{{.NetworkSettings.IPAddress}}' ${KIND_CLUSTER_NAME}-control-plane",
                        returnStdout: true,
                        // Ajoute ce bloc pour que le script ne fasse pas planter le pipeline s'il ne trouve pas l'IP
                        // dans le cas de setup plus complexes, mais pour Kind par d√©faut l'IP est l'IP du conteneur.
                        // Cependant, l'acc√®s se fait plus simplement via 127.0.0.1 ou localhost pour Kind.
                        // Nous utiliserons la m√©thode recommand√©e pour Kind.
                        
                    ).trim()

                    echo "\n-----------------------------------------------------"
                    echo "Application: http://localhost:${nodePort}"
                    echo "Metrics:     http://localhost:${nodePort}/metrics"
                    echo "Note: Kind expose les NodePorts via l'adresse localhost/127.0.0.1"
                    echo "-----------------------------------------------------\n"
                }
            }
        }
    }
}
